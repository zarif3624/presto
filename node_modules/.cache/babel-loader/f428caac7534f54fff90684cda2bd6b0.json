{"ast":null,"code":"import { useState, useEffect, useRef } from \"react\";\nimport firebase from \"./firebase\";\nconst firestore = firebase.firestore();\n/**** USERS ****/\n// Fetch user data\n\nexport function useUser(uid) {\n  return useQuery(uid && firestore.collection(\"users\").doc(uid));\n} // Update an existing user\n\nexport function updateUser(uid, data) {\n  return firestore.collection(\"users\").doc(uid).update(data);\n} // Create a new user\n\nexport function createUser(uid, data) {\n  return firestore.collection(\"users\").doc(uid).set({\n    uid,\n    ...data\n  }, {\n    merge: true\n  });\n}\n/**** ITEMS ****/\n\n/* Example query functions (modify to your needs) */\n// Fetch all items by owner\n\nexport function useItemsByOwner(owner) {\n  return useQuery(owner && firestore.collection(\"items\").where(\"owner\", \"==\", owner));\n} // Fetch item data\n\nexport function useItem(id) {\n  return useQuery(id && firestore.collection(\"items\").doc(id));\n} // Update an item\n\nexport function updateItem(id, data) {\n  return firestore.collection(\"items\").doc(id).update(data);\n} // Create a new item\n\nexport function createItem(data) {\n  return firestore.collection(\"items\").add(data);\n}\n/**** HELPERS ****/\n// Custom React hook that subscribes to a Firestore query\n\nfunction useQuery(query) {\n  const [queryState, setQueryState] = useState({\n    status: \"loading\",\n    data: undefined,\n    error: null\n  }); // Gives us previous query object if query is the same\n  // ensuring we don't unsubscribe and resubscribe below.\n\n  const queryCached = useQueryCache(query);\n  useEffect(() => {\n    // Skip if falsy value, as that allows us to wait on needed\n    // needed data before constructing query and passing it into useQuery.\n    if (queryCached) {\n      return queryCached.onSnapshot(response => {\n        // Get data for collection or doc\n        const data = response.docs ? getCollectionData(response) : getDocData(response);\n        setQueryState({\n          status: \"success\",\n          data: data,\n          error: null\n        });\n      }, error => {\n        setQueryState(state => ({\n          status: \"error\",\n          data: state.data,\n          error: error\n        }));\n      });\n    }\n  }, [queryCached]);\n  return queryState;\n} // Get doc data\n\n\nfunction getDocData(doc) {\n  return doc.exists === true ? {\n    id: doc.id,\n    ...doc.data()\n  } : null;\n} // Get array of doc data from collection\n\n\nfunction getCollectionData(collection) {\n  return collection.docs.map(doc => {\n    return {\n      id: doc.id,\n      ...doc.data()\n    };\n  });\n}\n\nfunction useQueryCache(query) {\n  // Ref for storing previous query object\n  const previousRef = useRef();\n  const previous = previousRef.current; // Determine if query object is equal to previous\n\n  const isEqual = !previous && !query || previous && query && previous.isEqual(query); // If not equal update previous to query (for next render)\n  // and then return new query below.\n\n  useEffect(() => {\n    if (!isEqual) {\n      previousRef.current = query;\n    }\n  });\n  return isEqual ? previous : query;\n}","map":{"version":3,"sources":["/Users/zarif.choudhury@ibm.com/Documents/c4c_disaster_proj/src/util/db.js"],"names":["useState","useEffect","useRef","firebase","firestore","useUser","uid","useQuery","collection","doc","updateUser","data","update","createUser","set","merge","useItemsByOwner","owner","where","useItem","id","updateItem","createItem","add","query","queryState","setQueryState","status","undefined","error","queryCached","useQueryCache","onSnapshot","response","docs","getCollectionData","getDocData","state","exists","map","previousRef","previous","current","isEqual"],"mappings":"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","sourcesContent":["import { useState, useEffect, useRef } from \"react\";\nimport firebase from \"./firebase\";\n\nconst firestore = firebase.firestore();\n\n/**** USERS ****/\n\n// Fetch user data\nexport function useUser(uid) {\n  return useQuery(uid && firestore.collection(\"users\").doc(uid));\n}\n\n// Update an existing user\nexport function updateUser(uid, data) {\n  return firestore.collection(\"users\").doc(uid).update(data);\n}\n\n// Create a new user\nexport function createUser(uid, data) {\n  return firestore\n    .collection(\"users\")\n    .doc(uid)\n    .set({ uid, ...data }, { merge: true });\n}\n\n/**** ITEMS ****/\n/* Example query functions (modify to your needs) */\n\n// Fetch all items by owner\nexport function useItemsByOwner(owner) {\n  return useQuery(\n    owner && firestore.collection(\"items\").where(\"owner\", \"==\", owner)\n  );\n}\n\n// Fetch item data\nexport function useItem(id) {\n  return useQuery(id && firestore.collection(\"items\").doc(id));\n}\n\n// Update an item\nexport function updateItem(id, data) {\n  return firestore.collection(\"items\").doc(id).update(data);\n}\n\n// Create a new item\nexport function createItem(data) {\n  return firestore.collection(\"items\").add(data);\n}\n\n/**** HELPERS ****/\n\n// Custom React hook that subscribes to a Firestore query\nfunction useQuery(query) {\n  const [queryState, setQueryState] = useState({\n    status: \"loading\",\n    data: undefined,\n    error: null,\n  });\n\n  // Gives us previous query object if query is the same\n  // ensuring we don't unsubscribe and resubscribe below.\n  const queryCached = useQueryCache(query);\n\n  useEffect(() => {\n    // Skip if falsy value, as that allows us to wait on needed\n    // needed data before constructing query and passing it into useQuery.\n    if (queryCached) {\n      return queryCached.onSnapshot(\n        (response) => {\n          // Get data for collection or doc\n          const data = response.docs\n            ? getCollectionData(response)\n            : getDocData(response);\n\n          setQueryState({\n            status: \"success\",\n            data: data,\n            error: null,\n          });\n        },\n        (error) => {\n          setQueryState((state) => ({\n            status: \"error\",\n            data: state.data,\n            error: error,\n          }));\n        }\n      );\n    }\n  }, [queryCached]);\n\n  return queryState;\n}\n\n// Get doc data\nfunction getDocData(doc) {\n  return doc.exists === true ? { id: doc.id, ...doc.data() } : null;\n}\n\n// Get array of doc data from collection\nfunction getCollectionData(collection) {\n  return collection.docs.map((doc) => {\n    return { id: doc.id, ...doc.data() };\n  });\n}\n\nfunction useQueryCache(query) {\n  // Ref for storing previous query object\n  const previousRef = useRef();\n  const previous = previousRef.current;\n\n  // Determine if query object is equal to previous\n  const isEqual =\n    (!previous && !query) || (previous && query && previous.isEqual(query));\n\n  // If not equal update previous to query (for next render)\n  // and then return new query below.\n  useEffect(() => {\n    if (!isEqual) {\n      previousRef.current = query;\n    }\n  });\n\n  return isEqual ? previous : query;\n}\n"]},"metadata":{},"sourceType":"module"}